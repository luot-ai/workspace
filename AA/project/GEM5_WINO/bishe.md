* SIMD和Vector的区别
  * SIMD涉及到的寄存器宽度是固定的，是拆分寄存器成多个槽位
    * 软硬件兼容性不好，编程人员需要在意计算的元素长度
  * vector向量长度自己设定
* Gem5的使用
  * Gem5会按照配置对指令的执行延迟进行模拟-周期精确
* Winograd卷积算法的分析
  * 他的核心循环是一个4x4的输入经由3x3的卷积核得到一个2x2的输出
    * 比滑窗法减少了乘法次数
  * 瓶颈
    * 内循环不变量重复加载(由于浮点架构寄存器不够)
      * 增加自定义向量寄存器：小buffer
    * 并行性开发不足
      * 在乱序CPU中，对并行度的挖掘受限于编译器、底层计算部件数量、流水线的发射宽度等因素，程序员难以灵活地通过编程进行调控。因此，有必要设计合适的向量化指令，以达到充分利用数据并行性的目的
      * 向量化指令：取算存
    * 数据依赖的指令，造成资源堵塞
      * 合并多级操作的指令
  * 设计
    * 流水化计算
      * 计算部件是一个三级流水的形式，前两级各4个加法器，最后一级是一个乘法器
      * 设计的三条计算指令有两条是2级，有一条是3级，可以背靠背地在计算部件中计算，复用计算部件
    * ctrlTable
      * 扩展指令使用自定义向量寄存器，并不是通用寄存器，无法通过原有的重命名逻辑解决数据相关，
        * 出于精确异常回滚的需要，ctrlTable一个是“推测性”的，另一个是“架构性”的
        * 前者用于控制指令的发射逻辑，后者用于在流水线冲刷时恢复前者。
        * ctrlTable为每个向量寄存器分配了一个值
      * 发射时检查
        * 其源寄存器和目的寄存器在推测性ctrlTable中对应的值是否满足指令发射条件
      * 写回时设置
    * busytable
      * 出于硬件资源消耗的考虑，目前设计中扩充的向量寄存器数目较少
      * 在不同循环迭代中，同一种指令对应的不同动态指令使用的源和目的向量寄存器号是一致的。
      * 由于这些动态指令对应的发射条件一致，因此需要避免靠后迭代的指令错误地发射，影响到靠前迭代中后续指令的计算
      * 每种指令分配1bit
        * 发射拉高，写回拉低
        * 被冲刷时需要拉低
* 工程流程
  * Gem5
    * ISA
      * Gem5源码经编译后，所有DSL代码都会被Python解析器解析为相应的C语言代码。
        * 扩充了自定义的向量寄存器
        * 根据指令的具体编码和定义，按照Gem5中提供的模板修改了译码部分
    * CPU
      * 主要修改了指令的发射、写回和唤醒这三个部分，其余部分复用原有架构即可。
        * 实现了指令的控制方案
          * ctrlTable和busyTable的维护
          * 指令发射条件的判断
          * 乱序流水线中边界情况的处理
      * 针对计算类指令，根据指令执行延迟对设计的计算单元进行了简单的配置
      * 针对访存类指令，其地址计算、访存请求发送和接收部分与原有指令相同，仅对访存的宽度进行了修改
  * 编译
    * 常用方法三种：
      * 在汇编程序中直接添加机器码；
      * 在源程序中利用.insn 模板进行编写；
      * 借助riscv-opcodes工具对编译工具进行修改，修改完成后程序员可以在C程序中内嵌汇编，反汇编之后也可以看到相应的指令
    * 使用的编译工具是RISC-V交叉编译工具链riscv-gnu-toolchain
      * 其源码实现较为复杂，但本文不关注其编译器内部具体的实现，仅需完成扩展指令识别部分的工作
        * 根据扩展指令的编码，按照指定的格式编写相应模板，利用riscv-opcodes工具生成扩展指令对应的宏；
        * 然后将这些宏加入工具链binutils部分的头文件中，并在头文件对应的源程序中增加指令定义
        * 最后，单独编译binutils部分的源码
    * 为每一条设计的自定义指令编写了相对应的内联汇编函数，将这些扩展指令封装到了C语言函数中
    * 改写winograd卷积算法
