# 基础知识

1. 是的， **FS 模式需要提供编译好的完整 Linux 镜像和根文件系统** ，gem5 会像一台真实计算机一样从 BIOS 启动 → 加载 kernel → 运行应用程序， **所有程序都跑在模拟的系统中** ，包括内核、驱动、文件系统都要模拟；而  **SE 模式只关注程序执行本身** ，不需要操作系统， **系统调用会由宿主机的 gem5 运行时直接拦截并模拟返回结果** ，因此运行速度快、调试简单，但行为不如 FS 模式真实。
2. gem5 它是事件驱动的模拟器，但它支持周期精确的微架构建模，是因为所有硬件行为都是以 tick 为粒度定义的事件，并通过调度系统精准控制每一个周期中要发生的行为。
   1. 比如在 O3CPU 中，指令发射、执行、写回、提交等都被严格划分在周期粒度上，通过事件时间戳维持时序关系。因此，尽管 gem5 用的是“事件机制”，但它本质是 “精确到每一拍的离散时间系统”，能够完整地建模流水线冲突、数据冒险、cache miss 等复杂微架构细节。

## 比较

> gem5解释型，它是一个 **事件驱动的架构模拟器** ，最大特点就是它能做到 **周期级别的精确模拟** ，就是你能看到每条指令在流水线里每个阶段干了啥、cache 命中了没、TLB 查到了没，特别适合搞微架构、做性能分析那种。

> 然后 QEMU 翻译型，它是 **功能级模拟器** ，最大的优点是快，它直接把 RISC-V 指令翻译成本地机器码跑，基本上能跑得飞快，所以拿它来做 OS bring-up、跑点软件测试特别合适。但是它不关心 timing，不太适合搞性能分析。

> Spike 是 RISC-V 官方出的参考模型-解释型，真的特别“干净”，没有 pipeline，没有 cache，它就是一条一条按规范来跑，跑得慢一点，但你可以拿它来当 **对拍模型** ，比如我写个 CPU，在仿真阶段用 Spike 去对每条指令做 diff-check，看我这条是不是对的。

## 工程

* scons构建GEM5可执行文件

  * gem5 是一个高度模块化、可配置的模拟器，涉及大量的 C++ 和 Python 混合代码。
  * SCons 比传统的 Make 更适合复杂依赖和可配置的系统，方便开发者灵活地启用或禁用不同的模块（如 CPU 类型、内存模型等）
* 编写仿真脚本

  * 指定ISA CPU
  * 指定主存 cache大小
  * 指定testbench
* 编译testbench

  * 使用m5函数

    * `m5op` 是 gem5 提供的一组“特殊功能”，比如：
      * 打印消息到 gem5 控制台（`m5_dump_stats()`）
      * 插入断点、测时间、退出仿真（`m5_exit()`）
      * 要使用这些函数需要：
        1. 包含头文件 `#include <m5ops.h>`
        2. 链接 `libm5.a`（静态库）
  * darknet中没有winograd实现

    * 增加其他开源库
    * 整合makefile
      * makefile

        * 核心代码EXECOBJA：可以理解为要执行的main函数
        * 内部静态库OBJ：用作库
        * 外部链接库
      * -I寻找头文件
      * vpath寻找源文件
  * 不能动态链接

    * 因为 gem5 的 SE 模式模拟的是“裸机上的用户程序”，它自己没有完整的操作系统（OS)
      * 你运行的 testbench 是在 **没有真正 Linux 系统的上下文下** 执行的；
      * 它不像 QEMU/VMware 可以模拟整个 OS 和系统调用加载器；
      * 所以你 testbench 所需的一切库和代码都必须在 **编译时打包进去** —— 也就是静态链接。
* 运行

  * ./build/{ISA}/gem5.{variant}
    [gem5 options] {simulation script} [script options]
* 输出

  * 程序仿真cycles数
  * 指令执行序列
  * trace-自定义，精确

## CPU

* 详见PPT和芝士，介绍的非常好
* 功能部件可配置：是否流水，执行延迟，操作种类
* tick( )
  * 结合trace可知，该部分代码是cpu执行最主要的代码，其中tick()是O3CPU所有时序模块的逻辑的实现函数，每周期tick()会被调用一次
  * 各阶段tick( )大致流程
    * 把上个阶段的指令读到自己的buffer中
    * 检查从后面来的squash信号和stall信号，并执行相应操作
    * 执行本阶段固有的操作
    * 若自己产生了squash或stall，则传播这个信号
