# 朴素的顺序双发射MIPS处理器

- 该项目来源于课程附加实验
- 在课内实验中，我们根据课本上介绍的相关知识，实现了一个 `可支持11条MIPS指令` 的简单五级流水线处理器，并通过 `暂停`和 `旁路`技术解决了流水线中出现的 `数据冲突`。此外，我们还实现了一个ICACHE
- 在该简单流水线的框架下，我继续完成 `附加实验`：封装好sram接口（debug+blkmem接口），扩展运算类指令，修改分支跳转类指令，实现乘除访存系列指令以及异常处理，最终通过了 `龙芯竞赛的功能测试`，包括仿真和上板。
- 到了寒假，我希望尝试着提升一下处理器的性能，于是对自己的设计做了一些迭代改进：包括调整接口为类SRAM接口，使用官方提供的类SRAM-AXI转换桥来实现 `AXI环境下的功能测试`，以及将ICACHE集成至CPU中，最后才是实现了InstBuffer和指令的双发射

  - 类SRAM接口【可以说成是封装为AXI接口】

    - 原有接口实现简单，每周期都可以返回数据，但实际上存储频率低于CPU，因此需要多周期返回数据，所以封装实现了一个带握手信号的AXI接口
  - Instbuffer【FIFO设计问题】

    - 防止后端执行时的阻塞影响前端取指，解耦合
  - 双发射【实战里再看看】

    - 译码阶段检查相关
      - 访存 乘除只有一条也很合理
      - RAW如何处理
      - 发射开始的2条指令必须要一起走，否则不是静态流水线了
    - 待发射两条指令的数据依赖&发射条件判断（前一条发射之后）
    - 主从流水线设计
      - 访存没法实现两个，并且乘除比较少，也没必要两个
      - 实现简单：主为1，先写回；从为2，后写回
        - 影响性能：第一条是简单运算，第二条是访存
    - 工程实现上instbuffer队列的移动

# 支持MIPS基准指令集的MIPS微系统设计

- 目标

  - 开发一个以 MIPS CPU为核心的计算机系统，包括前期差分测试环境搭建、CPU 核的设计、操作系统的启动以及搭建SOC等内容。
- 基本信息

  - 开发语言scala
    - 接口复用
    - 多发射友好-向量数据结构
    - 函数式编程
  - 四发射，但是重命名那基于时序考虑选择的宽度为3
  - Cache 8KB+8KB 一行64B，2路，64行
  - 开发历程
    - 0526-0620:coding
    - 0621-0703:coding and start_func
    - 0703-0710:func_pass(mem 2 days)
    - 0711:perf
    - 0715:uboot
    - 0728:fpga(0714-0723 0726/0727)
    - 0728-0811(0801bypass 0807-0809retire 0811freelist)
    - 0814-0816uart_bug
  - 乱序怎么个乱法
    - 乱序主要是靠：重命名，保留站乱序发射以及ROB按序提交实现的
      - 指令从前端取指队列出队之后，会来到派遣阶段，这一阶段我们进行重命名
        - 我们采取的是基于全物理器重命名的方法，需要使用源寄存器号从重命名映射表中读出对应的物理寄存器号
        - 要写回的指令需要从空闲物理寄存器表中获取目的物理寄存器号，更改这里的映射表
        - 然后这里重命名还需要考虑指令间相关（如果重命名宽度内的指令间有数据相关，那么就需要用该宽度内靠前指令的目的物理寄存器号作为自己的源物理寄存器号）
        - 我们采用分布式保留站，指令在这一级需要根据类型选择自己对应的保留站入队
      - 各功能单元保留站
        - 保留站是乱序的关键，这里操作数就绪并且满足优先级关系的指令能够越过前面的指令提前发射
        - 我们的优先级考虑的是年龄
        - 保留站也会监听后端写回信号，比对寄存器号，将合适的指令设为就绪
      - ROB
        - 指令在后端经历读操作数/执行/写回三个阶段，就会在ROB中标记已完成
        - 已完成的指令在ROB中按序退休（出队）
        - 正常的指令修改arat+归还freelist，分支预测失误或异常的指令需要在此完成重定向
- 为什么这么设计

  - 初期定架构

    - 决定性的因素，后期更改架构会极度费时费力
    - 看书/看已有的项目了解大致的框架-以及具体到某些部件的设计细节与不同方案的对比
      - 重命名的方式
      - 保留站分布式还是集中式
      - 寄存器映射表的方式
      - 分支预测错误恢复的方式
        - 基于ROB简单
        - 基于Checkpoint高效但实现复杂，占据资源
        - 难点在于如何识别已经乱序的指令的“身份”
    - TODO为什么rename/decode那个阶段的宽度是那样的
      - 我懂了，下次就说是三发射
      - 因为译码调到4会违约？
        - 具体怎么违约的：他这里改了，综合的时候不一定是这里违约？
  - 设计过程

    - 参数可配
      - 各流水级宽度按参数化写法
      - 快速仿真-测试性能
        - verilator的好处
    - 增量式的设计
      - 简易版分支预测和唤醒策略
  - 后期

    - 主频：本质加寄存器

      - 退休拆为2级
        - 原来1级会导致出rob队列逻辑复杂
      - 特殊情况多拍处理
        - 都是先把正常指令退休，再flush- 正常退休需要写arat，下一拍写入
          - flush需要用arat赋值给srat，下一拍写入
        - flush是一个常见的情况，后端redirect延迟较长，所以很多处都延迟一拍
          - dispatch的redirect前端是在后端指示的下一拍
      - 摩尔型自动机输出只与状态有关
      - 一些小trick
        - 提前算“”
          - 例如判断队列剩余待push进freelist数目，直觉上是，实际提前一拍
        - 信号解耦等
    - 性能导向优化
      ------------


      - 可做的优化点很多，但资源和主频也是需要考虑的，所以需要针对benchmark分析
      - CPI-基于热点基本块查看
        - 分支预测优化
        - 唤醒和旁路---不是全旁路
          - 旁路意味着读操作数的多选一，布线资源/连线延迟
          - load存在cache不命中等特殊情况，有可能无法及时地给需要的指令前递数据，因此需维护保留站中相应的标记位
            - 被设为就绪态的指令会发射，在读操作数阶段，需要前递数据而未得到的指令将会被阻塞
        - 派发逻辑优化
        - 写串口buffer
        - cache块大小调整
          - 大基本块-取指
        - freelist恢复优化
          - 刷新流水线后的恢复可以减少好几拍
          - 必须要保证diapatch放入的指令要归还phy时，rob中刷新前的phy已经全部归还好
- 难点

  - coding

    - dispatch：要根据靠前的是否
      - 派发逻辑：两个alu先采用较简单的派发策略
    - freelist push
      - 退休宽度内不是所有inst都需要push
  - retire由于延迟槽会很混乱，针对主频进行了很多优化，最后还是拆开成两级

    - 延迟槽：多发射退休，分支预测失误需要处理延迟槽
      - 延迟槽必须退休，延迟槽Exer必须处理
    - 得用自动机写
  - debug

    - 最后上板发现错误，和写串口buffer以及AXI W通道有关
      - 回滚提交记录
        - 回滚过程发现一个“意外解决”的bug
      - 上板定位具体错误段
        - 模拟器那边也是边写chisel边开发的，有错误
        - 对协议的错误理解
- 本人在项目中主要负责基于chisel的乱序CPU核的设计

  - 包括dispatch/rename/issue exe(part) retire
    - 重命名

      - 意义
        - 避免WAW/RAW
        - 提升指令调度自由度（和）
      - 基于ROB：进入ROB时自然的采用ROB号重命名，重命名比较简单，但是数据要在ROB和arch寄存器之间搬移。
        - 通常搭配数据捕捉，payload ram直接从旁路获取数据，不需要关心数据的来源
        - ROB开辟空间浪费
        - ROB项的回收和分配需要读写端口，操作数写回读取，臃肿
      - 基于全物理寄存器
        - 低功耗：数据无需搬移
        - 高主频：cluster的全物理寄存器堆
        - 重命名过程比较复杂：freelist & 需要一个额外的archsrat表
      - 寄存器映射表
        - 基于SRAM
          - 读写速度较快，直观易理解
          - 不利于checkpoint，因为每个checkpoint都需要复制一次SRAM
        - 基于CAM
          - 利于checkpoint，因为只需要保存有效位
          - 面积随物理寄存器个数增大，比较电路也会越来越多
    - 分发

      - 指令根据类型进入各功能单元保留站
      - 各功能单元具有一组保留站，分布式简化逻辑设计
      - 指令buffer多条指令维护

        - 保留站空位/ROB空位/freelist
        - 指令前后顺序【需要顺序写到ROB里】
    - 发射【RS】

      - 根据年龄选择源操作数就绪的指令发射到功能单元
      - 操作数就绪+满足优先级关系
      - 乱序关键：ALU0/1保留站乱序发射
      - mem/mdu完全顺序简化设计
      - 异常检测信息/DEST_AP/SRC_P/ROBIDX/PREV_PD
      - 集中式vs分布式
        - 集中式利用效率高，但是选择和唤醒电路比较复杂
        - 分布式：每个发射队列一个选择电路，简化设计
          - 各保留站之间会有互相的唤醒，分散的队列使布线复杂度上升
          - 只要某保留站满，后续的所有指令都没法通过(考虑某程序段包含大量的加减法指令)
    - 执行[ALU]

      - 分支预测
        - alu发出三个信号：happen target robidx
        - dispatch
          - 若rob给出延迟槽已经进入，则下一拍来到redirect状态
          - redirect前端，重新取指。并且block，不让指令往保留站和rob走
            - 在flushbackend的下一拍，解除block【为了保证mispre及其前面的指令退休】
            - flushbackend的时候，arat会复制给srat
      - 旁路和唤醒
        - 初期实现时，我们采用的方案是：两个整数保留站在发射时进行组内和组间唤醒，在读操作数阶段唤醒LSU和MDU
          - 后期观察到部分程序中LOAD指令往往处于指令数据相关性的顶端，因此我们加上了LOAD指令对访存和整数保留站的唤醒
        - 设计中的旁路包括
          - 两条主从整数流水线本身及相互之间的旁路
          - 访存流水线到其本身及整数流水线的旁路
          - 整数和访存流水线分别用执行段和访存3段产生的结果进行前递，且都在读操作数阶段获取前递结果。
    - 写回

      - 结果写回全物理寄存器：res->PRF[pdest]
      - 更改前端预测性的重命名映射表：srat[adest].pdest = pdest ? inprf->1↑
      - 异常和分支预测错误信息写入指令在rob中对应的位置：exdetect->rob[robidx]
    - 退休

      - 两级流水
        --------


        - 状态机集中式控制
        - 第一级流水
          - 根据 `状态` 和 `pop指令类型` 确定 **mask**
            - 即可以来到第二流水级的指令
        - 第二级流水
          - 指令退休，更改处理器状态
      - 处理特殊情况：异常&分支预测错误

        - 二级多周期自动机处理
      - 分支预测失误

        - 当拍退休延迟槽及其之前的指令，下一拍来到prenext
          - 在这一级判断下一拍进入什么状态
            - ds若正在retiring（即来到retire第二级）：misflush
              - dspoped但是没retireing：exer
            - ds若done（即目前在retire第一级并且已经done）：dsretire
            - 否则：mpnext->等待ds
          - mpnext
            - 处理逻辑同prenext状态，只不过可以明确此时不会dsretiring/dspoped
          - dsretire
            - 下一拍misflush
          - misflush
            - flushbackend拉高，刷掉后端流水线中剩余指令
      - 异常

        - normal_retire
        - flush
    - cache

      - 八股

        - 原理：时间和空间局部性
          - 空间的时候说到块大小
        - 结构
          - 层级结构
          - 内部两个表 index索引 tag&data
        - 提高效率
          - 多级缓存
          - 关键字优先
          - 写buffer
          - VIPT
            - index只用page内偏移部分的位
        - 直接映射-组相联-全相联
        - 写回写分配 直写不按写分配
        - 随机 先入先出 LRU
      - 可配置组相联缓存，默认配置下I-Cache大小8KB，2路，Cache line为64B。D-Cache大小8KB，2路，Cache line为64B。
      - 均为两级流水线访问，I-Cache单周期默认配置取16B，满足取出同一Cache line至多4条指令的要求。
      - 均采用LRU作为替换策略，选路部分参考开源项目rocket-chip[1]。D-Cache为写回Cache
