* [ ] 分析trace图

  * [X] 【想想为什么scb也会有错误的->分析branchIB】：因为前面的branch还没到exe，到了才会清空IB/fetchBuf
  * [ ] 想想各阶段为什么停顿
    * [ ] 取指：
    * [X] 译码：一次只抽IB一条指令去SCB【队头 且 不在SCH中 ->意味着前一条从SCB来到了SCH】
    * [X] SCB：SCH已有同wave指令【注意gem5里各流水级倒序执行，某周期指令从SCH去往EXE（上周期已标记可dispatch），该周期WAVE后续指令可以来到SCH（当拍决定是否标记dispatch）】///或者有写后读相关
    * [X] SCH：未被FU调度/资源占用
* [ ] 明天回来写一下访存相关的flag

  * [ ] 顺带着分析cache返回需要多少拍
  * [ ] 大致思路：iss占用的是那一流水级(所有指令都是issuePeriod需要四拍)；访存还有个vrf2MemBus要占用一周期(store是2周期)
  * [ ] 有个问题：会不会返回数据不需要4周期
  * [ ] 解决方法：先不管，写出来打印出来看看再说，大概就是iss4之后是cm(直到data back)
* [ ] 历史遗留问题选择解决：

  * [ ] cache几拍
  * [ ] 访存资源相关
  * [ ] 寄存器冲突
  * [ ] 访存地址计算
* [ ] 所有东西整合起来（周日）
* [ ] 整理到文档/PPT中（周日）
* [X] 先用trace搞，测试konata的接口
* [X] 再用dprintf，好处是不用管时间(法1确实很大)
* [ ] 或许可以写写另一个debugFlag，用于分析停顿原因（下周）
* [ ] 支持miss指令（下周）
* [ ] 然后才是各个simd的，这个可能下周再说

* 目前是按照仿照o3的方法
  1.取指目前只有pc们，还得想想【取指现在是包含了tlb，后续可以再改】
  2.译码需要改源码，输出seqnum
  3.rn就是scb
  4.sch就是dispatch
  5.issue就是执行
  6.cm就当做是影响到其他
