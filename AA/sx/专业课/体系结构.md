# QA

1. 讲了啥？
   1. 计算机系统的构成
   2. 如何更有效的设计这个部件
   3. 如何分析：提升性能，降低代价

2. 问题
   1. 大功耗问题（风冷已到达极限）； 
   2. 可以进一步有效地开发的指令级并行性已经很少； 
   3. 难以降低的存储器访问延时（存储器访问速度的提高缓慢）

3. 发展
   1. 提升单核性能
      1. RISC CACHE 流水
      2. 指令级并行(乱序)
   2. 多核

4. 计组VS体系结构
   1. 如何实现具体细节－－知其然
   2. 分析＋评测－知其所以然  并行计算机系统结构入门

5. 在这个时代，计算机的主要作用不再是独立使用的机器，而是一个应用系统或设备的组件（如马达一样），处理器技术是高性能智能设备的核心

6. 存储程序计算机 <- 冯·诺依曼结构计算机
   1. 运算/控制(CPU) 输入输出(IO) 存储
   2. 以运算器为中心/控制流由数据流产生/数据指令放同一存储/存储器按地址访问、线性编址

7. 计算机体系结构包括计算机系统设计的三个方面
   1. 计算机指令系统
      1. 程序员可见 软硬件分界面
         1. 指令集
         2. IO 中断 存储
         3. 机器工作状态
         4. 寄存器 寻址 数据类型
   2. **计算机组成/`微体系结构`**
      1. 功能部件及其连接
      2. 指令集结构的逻辑实现
         1. 流水线 多核互联 Cache结构
   3. 计算机硬件
      1. 具体的实现
      2. 集成电路工艺/封装

8. 系列机（family machine）是具有相同指令集结构，但组成和实现不同的一系列不同型号的计算机系统 
9. 应用对技术的发展提出需求，提供资金   ->  好的技术催生新的应用
10. 软件兼容：同一个软件可以不加修改地运行于体系结构相同的各档机器，
11. 集成电路密度大约每两年翻一番

12. 从执行程序的角度来看，并行性等级从低到高可分为：
    1. 指令内部并行：单条指令中各微操作之间的并行(流水线)
    2. 指令级并行：并行执行两条或两条以上的指令(超标量/乱序)
    3. 线程级并行：并行执行两个或两个以上的线程。通常是以一个进程内派生的多个线程为调度单位
    4. 任务级或过程级并行：并行执行两个或两个以上的过程或任务（程序段）， 以子程序或进程为调度单元
    5. 作业或程序级并行：并行执行两个或两个以上的作业或程序

13. SISD MIMD
    1. SIMD     阵列机 GPU
    2. MISD     容错
14. 三种途径提高并行性：时间重叠/资源重复/资源共享
15. 原则
    1. 大概率事件优先原则
       1. 对于大概率事件，给予更多的考虑
          1. 举例：分支预测失败恢复
    2. Amdahl定律
       1. 定义：加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的重要性
          1. 仅仅对计算机中的一部分做性能改进，则改进越多，系统获得的效果越小
          2. 具有高性能价格比的计算机系统是一个带宽平衡的系统，而不是看它使用的某些部件的性能
    3. 程序的局部性原理
16. CPU执行时间
    IC × CPI × 时钟周期时间 
    时钟周期时间：取决于硬件实现技术和`计算机组成`
    CPI：取决于`计算机组成`和**指令系统的结构**
    IC：取决于**指令系统的结构**和编译技术
17. 指令系统是计算机系统中软件与硬件交界
    1. 软件设计人员利用指令系统编制各种应用软件和系统软件；
    2. 硬件设计人员采用各种手段实现指令系统
18. 通用寄存器型指令集结构细分
    1. 寄存器-寄存器
       1. 优点：指令字长固定，指令结构简洁，是一种简单的代码生成模型，各种指令的执行时钟周期数相近
       2. 缺点：与指令中含存储器操作数的指令系统结构相比，指令条数多，目标代码不够紧凑，因而程序占用的空间比较大
    2. 寄存器-存储器
    3. 存储器-存储器
19. 寻址方式：
    立即数寻址|偏移寻址|寄存器寻址
    将寻址方式编码于操作码中，由操作码描述相应操作的寻址方式
20. 通过软件方法处理各种复杂的操作数类型，但是这样会大大降低系统的效率
    1. 例如咱们没实现浮点
21. 指令集设计
    1. 格式-如何用最短的位数来表示指令的操作信息和地址信息
    2. 功能-好钢用在刀刃上
22. 垃圾
    1. 八二
    2. 占用芯片面积，容易造成设计错误
    3. 复杂指令操作复杂，各条指令功能不均衡，不利于流水
23. 牛逼
    1. 选取使用频率最高的指令，并补充一些最有用的指令
    2. 功能简单，指令长度相同，便于流水
    3. 只有load和store操作指令才访问存储器，减少访存开销

24. 数据通路
    1. 时钟触发到输出稳定的时间`触发器延迟` -> 关键路径延迟 -> 时钟触发前数据需要稳定一段时间`建立时间`<最小时钟周期
    2. 时钟触发后数据需稳定一段时间`保持时间` < 最短路径+`除法器延迟`  

25. 流水线
    1. 将一重复的时序过程分解为若干子过程，每个子过程完成一定的功能，并且可以与其他子过程同时执行
    2. 特点
       1. 流水过程由多个相关的子过程组成，这些子过程称为流水线的“级”或“段”，段的数目称为流水线的“深度”
       2. 每个子过程由专用的功能段实现
       3. 各功能段的时间应基本相等
       4. 流水线需要经过一定的通过时间才能稳定
       5. 流水技术适合于大量重复的时序过程
    3. 性能指标
       1. 吞吐量指`单位时间内流水线所完成的任务数或输出结果的数量`
       2. 加速比是指流水线速度与等功能的非流水线速度之比
       3. 效率指`流水线的设备利用率`:由于流水线有通过时间和排空时间，所以流水线的各段并非一直满负荷工作
    4. **建立时间+触发器延迟**=额外开销

26. 若干问题
    1. 是为了增加吞吐量
    2. 增加深度？-> 分支延迟的惩罚 + 旁路网络更复杂(load指令与之后的数据相关问题)
    3. 相关 -> 流水线的冒险   限制 -> 流水线

27. 冒险：指的是由于指令之间存在的某种关联，导致后一条指令不能如期的执行
    1. 结构：FU没流水+FU不够
    2. 数据：真相关<旁路>  +  名相关(输出相关/反相关)<重命名>

28. 旁路就是需要把结果往回前递，并且需要一定的组合逻辑来生成后续指令选择源操作数的多路选择信号
29. 分支
    1. 静态：冻结排空流水线+单纯预测不跳转+延迟槽
    2. 动态：分支预测
30. 具有向量数据表示和相应向量指令的流水线处理机称为（向量流水线处理机）->TODO:

## 指令级并行

1. 当指令之间不存在相关时，它们在流水线中是可以重叠起来并行执行的。这种指令序列中存在的`潜在并行性`称为指令级并行
2. `循环级并行`循环体的不同迭代之间存在的并行性
3. 相关
   1. 数据相关（也称真数据相关、数据流相关）-RAW
      1. 无法消除这种固有的相关性，只能通过某种手段来弥补由这一类相关所导致的延迟
      2. 软件-指令调度
      3. 硬件-旁路或调度
   2. 名相关（包括反相关、输出相关）
      1. 软件-重命名-直接改名
      2. 硬件-重命名-SRAT
4. 一旦一条指令受阻，其后的指令都将停顿
5. 记分牌
   1. 数据相关问题
      1. issue级等待`结构冲突` `WAW`
      2. RO级等待`RAW`
      3. 写回时`WAR`-不能有还未读完操作数仍在等待的指令
   2. **原理**：
      1. 每条指令均经过记分牌，记录各指令间数据相关的信息，进行相关检测，控制指令的流出和执行
      2. 如果记分牌判断出一条指令不能立即执行，它就检测硬件的变化从而决定何时能够执行
      3. 集中控制寄存器与处理单元的数据传送，检测或消除数据相关性，加快程序执行速度
   3. 部件：
      1. 指令状态表：记录正在执行的各条指令进入到哪一个阶段
      2. `功能部件的状态表`
         1. Busy：指示功能部件是否工作
         2. Op：功能部件当前执行的操作
         3. Fi：目的寄存器编号
         4. Fj，Fk：源寄存器编号
         5. Qj，Qk：向源寄存器Fj，Fk中写结果的功能部件
         6. Rj，Rk：标示Fj，Fk是否就绪，是否已经被使用
      3. 结果寄存器状态表：记录写入寄存器的功能部件编号
6. TOMASOLO
   1. 与记分牌的区别
      1. Tomasulo算法中，冲突检测和执行控制是分布的，利用保留站实现
      2. Tomasulo算法不检查WAR和WAW相关，通过算法本身消除
      3. 计算结果通过专用通道直接从功能部件进入到保留站进行缓冲，而不是写到寄存器
   2. **原理**：
      1. Tomasulo算法不检查WAR和WAW相关，通过算法本身消除，利用保留站来实现重命名
         1. 从读的角度，从写的角度
      2. 计算结果通过专用通道直接从功能部件进入到保留站进行缓冲，而不是写到寄存器
         1. 所以要在保留站挂上源操作数的值
   3. 为了保证正确的异常行为， Tomasulo算法对指令的执行有一个限制：一旦有一条分支指令还没有执行完，其后的指令是不允许进入执行段
   4. 与我们的区别
      1. 我们的重命名是全物理寄存器重命名，发射后读
         1. 他们是基于保留站重命名-发射前读
      2. 我们实现了前瞻执行
7. 前瞻执行
   1. 基于硬件的前瞻执行结合了3种思想：
      1. 采用动态分支预测来选择后续执行的指令
      2. 在控制相关的结果尚未出来之前，前瞻地执行后续指令
      3. 加入ROB，一个提交阶段
   2. 缺点
      1. 备份太多
      2. 传递太多
      3. 保留站既有数据又有控制位

