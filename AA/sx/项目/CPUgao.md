# 通用

* 如何提高处理器性能
  * 主频
    * 拆分流水级
    * 特殊事件多周期处理
  * CPI
    * 分支预测
    * cache
    * 多发射
    * 乱序
      * 提高指令级并行
    * 旁路+提前唤醒
* 如何提高指令级并行
  * 超标量
  * 乱序
  * 分支预测
  * 软件层面
    * 指令重排
    * 循环展开
* 缓存一致性
  * MSI
  * MESI
    * E：从主存加载数据后，若只有自己持有副本，进入E状态
    * 将来写入无需通知其他核：避免无效写广播
  * MOESI
    * O：多个缓存有副本，其中一个写了最新值，由他来提供值
    * 避免频繁写回
* 中断异常
  * 保存PC
  * 设置原因
  * 跳转地址
  * 软件负责：根据设置的原因跳转到对应地址处理

# 朴素的顺序双发射MIPS处理器

- 该项目来源于课程附加实验
- 在课内实验中，我们根据课本上介绍的相关知识，实现了一个 `可支持11条MIPS指令` 的简单五级流水线处理器，并通过 `暂停`和 `旁路`技术解决了流水线中出现的 `数据冲突`。此外，我们还实现了一个ICACHE
- 在该简单流水线的框架下，我继续完成 `附加实验`：封装好sram接口（debug+blkmem接口），扩展运算类指令，修改分支跳转类指令，实现乘除访存系列指令以及异常处理，最终通过了 `龙芯竞赛的功能测试`，包括仿真和上板。
- 到了寒假，我希望尝试着提升一下处理器的性能，于是对自己的设计做了一些迭代改进：包括调整接口为类SRAM接口，使用官方提供的类SRAM-AXI转换桥来实现 `AXI环境下的功能测试`，以及将ICACHE集成至CPU中，最后才是实现了InstBuffer和指令的双发射

  - 类SRAM接口【可以说成是封装为AXI接口】

    - 原有接口实现简单，每周期都可以返回数据，但实际上存储频率低于CPU，因此需要多周期返回数据，所以封装实现了一个带握手信号的AXI接口
  - Instbuffer【FIFO设计问题】

    - 防止后端执行时的阻塞影响前端取指，解耦合
  - 双发射【实战里再看看】

    - 译码阶段检查相关
      - 访存 乘除只有一条也很合理
      - RAW如何处理
      - 发射开始的2条指令必须要一起走，否则不是静态流水线了
    - 待发射两条指令的数据依赖&发射条件判断（前一条发射之后）
    - 主从流水线设计
      - 访存没法实现两个，并且乘除比较少，也没必要两个
      - 实现简单：主为1，先写回；从为2，后写回
        - 影响性能：第一条是简单运算，第二条是访存
    - 工程实现上instbuffer队列的移动
  - AXI(握手)

    - 地址 数据 大小
    - 5通道
      - 读写分离，为性能
      - 写
        - 写请求，双方握手
          - 地址 大小
        - 写数据
          - 分开是为了提升效率，相当于从设备也流水化处理地址和数据
        - 写响应
          - 告诉主方已经接收到写数据，主方因此可以发送读请求

## 支持MIPS基准指令集的MIPS微系统设计

- 该项目的目标是：开发一个以 MIPS CPU为核心的计算机系统，包括前期差分测试环境搭建、CPU 核的设计、操作系统的启动以及搭建SOC等内容。
- 该项目实际上将作为今年“龙芯杯”全国大学生计算机系统能力培养大赛的参赛作品。
- 基本

  - 四发射，但是重命名那基于时序考虑选择的宽度为3
  - Cache 8KB+8KB 一行64B，2路，64行
  - 乱序怎么个乱法
    - RS保留未就绪的指令，使就绪指令乱序发射
    - 重命名机制用于消除写后写和读后写相关，同时可以检测写后读相关
    - ROB保证了精确异常
- 软

  - scala

    - 接口复用，编写修改简单
    - 多发射友好
    - 函数式编程
  - 差分测试

    - Linux系统下的cpp工程，依赖verilator编译verilog生成cpp语言的电路仿真代码。
    - 仿真速度远大于Xilinx的EDA，大大减少了debug的时间。
    - 此外，该测试系统具有可高度自定义的数据统计方式，极大便利了性能优化的工作，能够更高效的找出性能瓶颈
- 本人在项目中主要负责基于chisel的乱序CPU核的设计

  - 包括dispatch/rename/issue exe(part) retire
    - 重命名

      - 基于ROB：进入ROB时自然的采用ROB号重命名，重命名比较简单，但是数据要在ROB和arch寄存器之间搬移。
        - 通常搭配数据捕捉，payload ram直接从旁路获取数据，不需要关心数据的来源
        - ROB开辟空间浪费
        - ROB项的回收和分配需要读写端口，操作数写回读取，臃肿
      - 基于全物理寄存器
        - 低功耗：数据无需搬移
        - 高主频：cluster的全物理寄存器堆
        - 重命名过程比较复杂：freelist & 需要一个额外的archsrat表
    - 分发

      - 指令根据类型进入各 功能单元保留站
      - 各功能单元具有一组保留站，分布式简化逻辑设计
      - 指令buffer多条指令维护

        - 保留站空位/ROB空位/freelist
        - 指令前后顺序【需要顺序写到ROB里】
    - 发射【RS】

      - 根据年龄选择源操作数就绪的指令发射到功能单元
      - 操作数就绪+满足优先级关系
      - 乱序关键：ALU0/1保留站乱序发射
      - mem/mdu完全顺序简化设计
      - 异常检测信息/DEST_AP/SRC_P/ROBIDX/PREV_PD
      - 集中式vs分布式
        - 集中式利用效率高，但是选择和唤醒电路比较复杂
        - 分布式：每个发射队列一个选择电路，简化设计
          - 各保留站之间会有互相的唤醒，分散的队列使布线复杂度上升
          - 只要某保留站满，后续的所有指令都没法通过(考虑某程序段包含大量的加减法指令)
    - 执行[ALU]

      - 分支预测失误恢复
        - 禁止分发入dispatch
        - 清空instbuffer
        - 前端重定向
        - 后端rob清空后允许前端分发
    - 写回

      - res->PRF[pdest]
      - srat[adest].pdest = pdest ? inprf->1↑
      - exdetect->rob[robidx]
    - 退休

      - 两级
        - 一级从rob中pop出来
        - 二级真正的退休
      - 处理特殊情况：异常&分支预测错误
        - 二级多周期自动机处理
    - cache

      - 八股

        - 原理：时间和空间局部性
          - 空间的时候说到块大小
        - 结构
          - 层级结构
          - 内部两个表 index索引 tag&data
        - 提高效率
          - 多级缓存
          - 关键字优先
          - 写buffer
          - VIPT
            - index只用page内偏移部分的位
        - 直接映射-组相联-全相联
        - 写回写分配 直写不按写分配
        - 随机 先入先出 LRU
      - 可配置组相联缓存，默认配置下I-Cache大小8KB，2路，Cache line为64B。D-Cache大小8KB，2路，Cache line为64B。
      - 均为两级流水线访问，I-Cache单周期默认配置取16B，满足取出同一Cache line至多4条指令的要求。
      - 均采用LRU作为替换策略，选路部分参考开源项目rocket-chip[1]。D-Cache为写回Cache
