# 通用

* 如何提高处理器性能
  * 主频
    * 拆分流水级
    * 特殊事件多周期处理
  * CPI
    * 分支预测
    * cache
    * 多发射
    * 乱序
      * 提高指令级并行
    * 旁路+提前唤醒
* 如何提高指令级并行
  * 超标量
  * 乱序
  * 分支预测
  * 软件层面
    * 指令重排
    * 循环展开
* 缓存一致性
  * MSI
  * MESI
    * E：从主存加载数据后，若只有自己持有副本，进入E状态
    * 将来写入无需通知其他核：避免无效写广播
  * MOESI
    * O：多个缓存有副本，其中一个写了最新值，由他来提供值
    * 避免频繁写回
* 中断异常
  * 保存PC
  * 设置原因
  * 跳转地址
  * 软件负责：根据设置的原因跳转到对应地址处理

# 朴素的顺序双发射MIPS处理器

- 该项目来源于课程附加实验
- 在课内实验中，我们根据课本上介绍的相关知识，实现了一个 `可支持11条MIPS指令` 的简单五级流水线处理器，并通过 `暂停`和 `旁路`技术解决了流水线中出现的 `数据冲突`。此外，我们还实现了一个ICACHE
- 在该简单流水线的框架下，我继续完成 `附加实验`：封装好sram接口（debug+blkmem接口），扩展运算类指令，修改分支跳转类指令，实现乘除访存系列指令以及异常处理，最终通过了 `龙芯竞赛的功能测试`，包括仿真和上板。
- 到了寒假，我希望尝试着提升一下处理器的性能，于是对自己的设计做了一些迭代改进：包括调整接口为类SRAM接口，使用官方提供的类SRAM-AXI转换桥来实现 `AXI环境下的功能测试`，以及将ICACHE集成至CPU中，最后才是实现了InstBuffer和指令的双发射

  - 类SRAM接口【可以说成是封装为AXI接口】

    - 原有接口实现简单，每周期都可以返回数据，但实际上存储频率低于CPU，因此需要多周期返回数据，所以封装实现了一个带握手信号的AXI接口
  - Instbuffer【FIFO设计问题】

    - 防止后端执行时的阻塞影响前端取指，解耦合
  - 双发射【实战里再看看】

    - 译码阶段检查相关
      - 访存 乘除只有一条也很合理
      - RAW如何处理
      - 发射开始的2条指令必须要一起走，否则不是静态流水线了
    - 待发射两条指令的数据依赖&发射条件判断（前一条发射之后）
    - 主从流水线设计
      - 访存没法实现两个，并且乘除比较少，也没必要两个
      - 实现简单：主为1，先写回；从为2，后写回
        - 影响性能：第一条是简单运算，第二条是访存
    - 工程实现上instbuffer队列的移动
  - AXI(握手)

    - 地址 数据 大小
    - 5通道
      - 读写分离，为性能
      - 写
        - 写请求，双方握手
          - 地址 大小
        - 写数据
          - 分开是为了提升效率，相当于从设备也流水化处理地址和数据
        - 写响应
          - 告诉主方已经接收到写数据，主方因此可以发送读请求

## 支持MIPS基准指令集的MIPS微系统设计

- 该项目的目标是：开发一个以 MIPS CPU为核心的计算机系统，包括前期差分测试环境搭建、CPU 核的设计、操作系统的启动以及搭建SOC等内容。
- 该项目实际上将作为今年“龙芯杯”全国大学生计算机系统能力培养大赛的参赛作品。
- 基本

  - 四发射，但是重命名那基于时序考虑选择的宽度为3
  - Cache 8KB+8KB 一行64B，2路，64行
  - 乱序怎么个乱法
    - 乱序主要是靠：重命名，保留站乱序发射以及ROB按序提交实现的
      - 指令从前端取指队列出队之后，会来到派遣阶段，这一阶段我们进行重命名
        - 我们采取的是基于全物理器重命名的方法，需要使用源寄存器号从重命名映射表中读出对应的物理寄存器号
        - 要写回的指令需要从空闲物理寄存器表中获取目的物理寄存器号，更改这里的映射表
        - 然后这里重命名还需要考虑指令间相关（如果重命名宽度内的指令间有数据相关，那么就需要用该宽度内靠前指令的目的物理寄存器号作为自己的源物理寄存器号）
        - 我们采用分布式保留站，指令在这一级需要根据类型选择自己对应的保留站入队
      - 各功能单元保留站
        - 保留站是乱序的关键，这里操作数就绪并且满足优先级关系的指令能够越过前面的指令提前发射
        - 我们的优先级考虑的是年龄
        - 保留站也会监听后端写回信号，比对寄存器号，将合适的指令设为就绪
      - ROB
        - 指令在后端经历读操作数/执行/写回三个阶段，就会在ROB中标记已完成
        - 已完成的指令在ROB中按序退休（出队）
        - 正常的指令修改arat+归还freelist，分支预测失误或异常的指令需要在此完成重定向
- 难点

  - 延迟槽：多发射退休，分支预测失误需要处理延迟槽
    - 延迟槽必须退休，延迟槽Exer必须处理
- 软

  - scala

    - 接口复用，编写修改简单
    - 多发射友好
    - 函数式编程
  - 差分测试

    - Linux系统下的cpp工程，依赖verilator编译verilog生成cpp语言的电路仿真代码。
    - 仿真速度远大于Xilinx的EDA，大大减少了debug的时间。
    - 此外，该测试系统具有可高度自定义的数据统计方式，极大便利了性能优化的工作，能够更高效的找出性能瓶颈
- 本人在项目中主要负责基于chisel的乱序CPU核的设计

  - 包括dispatch/rename/issue exe(part) retire
    - 重命名

      - 基于ROB：进入ROB时自然的采用ROB号重命名，重命名比较简单，但是数据要在ROB和arch寄存器之间搬移。
        - 通常搭配数据捕捉，payload ram直接从旁路获取数据，不需要关心数据的来源
        - ROB开辟空间浪费
        - ROB项的回收和分配需要读写端口，操作数写回读取，臃肿
      - 基于全物理寄存器
        - 低功耗：数据无需搬移
        - 高主频：cluster的全物理寄存器堆
        - 重命名过程比较复杂：freelist & 需要一个额外的archsrat表
    - 分发

      - 指令根据类型进入各功能单元保留站
      - 各功能单元具有一组保留站，分布式简化逻辑设计
      - 指令buffer多条指令维护

        - 保留站空位/ROB空位/freelist
        - 指令前后顺序【需要顺序写到ROB里】
    - 发射【RS】

      - 根据年龄选择源操作数就绪的指令发射到功能单元
      - 操作数就绪+满足优先级关系
      - 乱序关键：ALU0/1保留站乱序发射
      - mem/mdu完全顺序简化设计
      - 异常检测信息/DEST_AP/SRC_P/ROBIDX/PREV_PD
      - 集中式vs分布式
        - 集中式利用效率高，但是选择和唤醒电路比较复杂
        - 分布式：每个发射队列一个选择电路，简化设计
          - 各保留站之间会有互相的唤醒，分散的队列使布线复杂度上升
          - 只要某保留站满，后续的所有指令都没法通过(考虑某程序段包含大量的加减法指令)
    - 执行[ALU]

      - 分支预测

        - alu发出三个信号：happen target robidx
        - dispatch
          - 若rob给出延迟槽已经进入，则下一拍来到redirect状态
          - redirect前端，重新取指。并且block，不让指令往保留站和rob走
            - 在flushbackend的下一拍，解除block【为了保证mispre及其前面的指令退休】
            - flushbackend的时候，arat会复制给srat
    - 写回

      - 结果写回全物理寄存器：res->PRF[pdest]
      - 更改前端预测性的重命名映射表：srat[adest].pdest = pdest ? inprf->1↑
      - 异常和分支预测错误信息写入指令在rob中对应的位置：exdetect->rob[robidx]
    - 退休

      - 两级
        - 一级从rob中pop出来
        - 二级真正的退休
      - 处理特殊情况：异常&分支预测错误
        - 二级多周期自动机处理
      - 分支预测失误
        - 当拍退休延迟槽及其之前的指令，下一拍来到prenext
          - 在这一级判断下一拍进入什么状态
            - ds若正在retiring（即来到retire第二级）：misflush
              - dspoped但是没retireing：exer
            - ds若done（即目前在retire第一级并且已经done）：dsretire
            - 否则：mpnext->等待ds
          - mpnext
            - 处理逻辑同prenext状态，只不过可以明确此时不会dsretiring/dspoped
          - dsretire
            - 下一拍misflush
          - misflush
            - flushbackend拉高，刷掉后端流水线中剩余指令
    - cache

      - 八股

        - 原理：时间和空间局部性
          - 空间的时候说到块大小
        - 结构
          - 层级结构
          - 内部两个表 index索引 tag&data
        - 提高效率
          - 多级缓存
          - 关键字优先
          - 写buffer
          - VIPT
            - index只用page内偏移部分的位
        - 直接映射-组相联-全相联
        - 写回写分配 直写不按写分配
        - 随机 先入先出 LRU
      - 可配置组相联缓存，默认配置下I-Cache大小8KB，2路，Cache line为64B。D-Cache大小8KB，2路，Cache line为64B。
      - 均为两级流水线访问，I-Cache单周期默认配置取16B，满足取出同一Cache line至多4条指令的要求。
      - 均采用LRU作为替换策略，选路部分参考开源项目rocket-chip[1]。D-Cache为写回Cache
