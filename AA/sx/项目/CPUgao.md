# 朴素的顺序双发射MIPS处理器

- 该项目来源于课程附加实验
- 在课内实验中，我们根据课本上介绍的相关知识，实现了一个 `可支持11条MIPS指令` 的简单五级流水线处理器，并通过 `暂停`和 `旁路`技术解决了流水线中出现的 `数据冲突`。此外，我们还实现了一个ICACHE
- 在该简单流水线的框架下，我继续完成 `附加实验`：封装好sram接口（debug+blkmem接口），扩展运算类指令，修改分支跳转类指令，实现乘除访存系列指令以及异常处理，最终通过了 `龙芯竞赛的功能测试`，包括仿真和上板。
- 到了寒假，我希望尝试着提升一下处理器的性能，于是对自己的设计做了一些迭代改进：包括调整接口为类SRAM接口，使用官方提供的类SRAM-AXI转换桥来实现 `AXI环境下的功能测试`，以及将ICACHE集成至CPU中，最后才是实现了InstBuffer和指令的双发射

  - 类SRAM接口【可以说成是封装为AXI接口】

    - 原有接口实现简单，每周期都可以返回数据，但实际上存储频率低于CPU，因此需要多周期返回数据，所以封装实现了一个带握手信号的AXI接口
  - Instbuffer【FIFO设计问题】

    - 防止后端执行时的阻塞影响前端取指，解耦合
  - 双发射【实战里再看看】

    - 待发射两条指令的数据依赖&发射条件判断（前一条发射之后）
    - 主从流水线设计
      - 访存没法实现两个，并且乘除比较少，也没必要两个
      - 实现简单：主为1，先写回；从为2，后写回
        - 影响性能：第一条是简单运算，第二条是访存
    - 工程实现上instbuffer队列的移动
  - AXI(握手)/类SRAM

    - 区别(p198)
    - 设计考虑的问题（p190）TODO:

## 支持MIPS基准指令集的MIPS微系统设计

- 该项目的目标是：开发一个以 MIPS CPU为核心的计算机系统，包括前期差分测试环境搭建、CPU 核的设计、操作系统的启动以及搭建SOC等内容。
- 该项目实际上将作为今年“龙芯杯”全国大学生计算机系统能力培养大赛的参赛作品。
- 基本
  - 四发射，但是重命名那基于时序考虑选择的宽度为3
  - Cache 8KB+8KB 一行64B，2路，64行
- 本人在项目中主要负责基于chisel的乱序CPU核的设计
  - 包括dispatch/rename/issue exe(part) retire
    - 重命名

      - 基于ROB：进入ROB时自然的采用ROB号重命名，重命名比较简单，但是数据要在ROB和arch寄存器之间搬移。
        - 通常搭配数据捕捉，payload ram直接从旁路获取数据，不需要关心数据的来源
        - ROB开辟空间浪费
        - ROB项的回收和分配需要读写端口，操作数写回读取，臃肿
      - 基于全物理寄存器
        - 低功耗：数据无需搬移
        - 高主频：cluster的全物理寄存器堆
        - 重命名过程比较复杂：freelist & 需要一个额外的archsrat表
    - 分发

      - 指令根据类型进入各 功能单元保留站
      - 各功能单元具有一组保留站，分布式简化逻辑设计
      - 指令buffer多条指令维护

        - 保留站空位/ROB空位/freelist
        - 指令前后顺序【需要顺序写到ROB里】
    - 发射【RS】

      - 根据年龄选择源操作数就绪的指令发射到功能单元
      - 操作数就绪+满足优先级关系
      - 乱序关键：ALU0/1保留站乱序发射
      - mem/mdu完全顺序简化设计
      - 异常检测信息/DEST_AP/SRC_P/ROBIDX/PREV_PD
    - 执行[ALU]

      - 分支预测失误恢复
        - 禁止分发入dispatch
        - 清空instbuffer
        - 前端重定向
        - 后端rob清空后允许前端分发
    - 写回

      - res->PRF[pdest]
      - srat[adest].pdest = pdest ? inprf->1↑
      - exdetect->rob[robidx]
    - 退休

      - 两级
        - 一级从rob中pop出来
        - 二级真正的退休
      - 处理特殊情况：异常&分支预测错误
        - 二级多周期自动机处理，
