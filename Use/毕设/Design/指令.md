# 指令编码

* opcode=0x0b 00010[0x02]+11(其余的都是压缩指令)

| ins        | funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12]  | rd[11:7]                                   |
| ---------- | ------------- | ---------- | ---------- | -------------- | ------------------------------------------ |
| ld_tilerow | 0             | /          | 地址       | 010            | 8:output 0-3:input 4-7:kernel              |
| aamul      | 1             | /          | /          | 000【没用GPR】 | 1:02[0] 2:12[1] 3:21[2] 4:31[3] 5:1221[12] |
| triadd     | 2             | /          | /          | 000【没用GPR】 | 1:012[0] 2:321[3]                          |
| oacc       | 3             | /          | /          | 000【没用GPR】 | /                                          |
| wb_tile    | 4             | /          | 地址       | 010            | /                                          |

## 注意事项

* **aamul 23可能会出现读后写问题，目前预留了一个同时操作两组的指令5，因为是流水且操作数相同，所以延迟也就多一拍**
* **triadd 那23不知道可不可以提前置0，若置零可能后面的ld会把寄存器填上**
* **oacc 其实可以拆开，但是不方便指令编码**
* 如何解决数据冲突和控制冲突
  * 使用map
    * *更新kernel时map该怎么办？可能需要特殊的指令来设置map？*
    * 多次迭代间仍可能有问题
      * 指令先来肯定比后来先做
      * 用序列号去做
* 瓶颈
  * output只有一个，其实可以双buffer，这样不用等写回，就可以load

## 策略

* 循环外ld_tilerow将kernel写入 4 5 6 7 寄存器
* 循环内ld_tilerow将 ifmap写入 0 1 2 3 寄存器

  * ld_tilerow读取output写入     8	    寄存器
* 只有一个流水部件	4+	4+	4*

  * map就绪的aamul执行，delay=6/7，修改map0123
  * map就绪的triadd执行，delay=3/4，修改map03，map12待定
  * map038就绪，即可执行oacc，【delay=(3or4)+1，其实是两组，但流水】map[03]=0

## 指令相关性

设计长度为9的map：

| ins        | 数据前相关                       | 控制前相关 | 数据后相关 | 控制后相关          |
| ---------- | -------------------------------- | ---------- | ---------- | ------------------- |
| ld_tilerow | rs1-地址                         | map[rd]=0  | map[rd]=1  |                     |
| aamul      | map[idx12]=1<br />*map[idx1+4]=1 |            | map[rd]=2  |                     |
| triadd     | map[idx123]=2                    |            | map[0/3]=4 | ~~map[idx12]=0？~~ |
| oacc       | map[03]=4<br />map[8]=1          |            | map[8]=2   | map[03]=0           |
| wb_tile    | map[8]=2<br />rs1-地址           |            |            | map[8]=0            |

## QA

* 为什么不一下子读16个

  * 因为部件有限，不想等前面16个数全部清空才唤醒指令
  * 对于后面指令的唤醒也有同样的道理
  * 此外，这里load部件刚好也是4个，做4*4也算合理
* 那为什么不能1个1个读

  * 首先是感觉可能一起读效率高
  * 其次是后面我需要进行向量操作

    * 因为发现扩充部件后，刚好有合适的策略
      * 可以流水啥的
