# 指令编码

* opcode=0x0b 00010[0x02]+11(其余的都是压缩指令)

| ins        | funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12]  | rd[11:7]                                   |
| ---------- | ------------- | ---------- | ---------- | -------------- | ------------------------------------------ |
| ld_tilerow | 0             | /          | 地址       | 010            | 8:output 0-3:input 4-7:kernel              |
| aamul      | 1             | /          | /          | 000【没用GPR】 | 1:02[0] 2:12[1] 3:21[2] 4:31[3] 5:1221[12] |
| triadd     | 2             | /          | /          | 000【没用GPR】 | 1:012[0] 2:321[3]                          |
| oacc       | 3             | /          | /          | 000【没用GPR】 | /                                          |
| wb_tile    | 4             | /          | 地址       | 010            | /                                          |

## 注意事项

* aamul1221是担心aamul12和aamul21读写冲突，因为是流水且操作数相同，所以延迟也就多一拍
* triadd 那23不知道可不可以提前置0，若置零可能后面的ld会把寄存器填上,所以暂时放在oacc全置零
* oacc 其实可以拆开，但是不方便指令编码
* 访存违例问题指的是：load同地址指令先于store去做，在咱们这不会

  * 例如store1 load1 store2 load2，store1->load1->load2
* 目前更新kernel和其他custom保持互定序
* ***branch mispredict ????? ????? ????? ????? ????? ????? ????? ????? ?????***
* 瓶颈

  * output只有一个，其实可以双buffer，这样不用等写回，就可以load

## 策略

* 循环外ld_tilerow将kernel写入 4 5 6 7 寄存器
* 循环内ld_tilerow将 ifmap写入 0 1 2 3 寄存器

  * ld_tilerow读取output写入     8	    寄存器
* 只有一个流水部件	4+	4+	4*

  * map就绪的aamul执行，delay=6/7，修改map0123
  * map就绪的triadd执行，delay=3/4，修改map03，map12待定
  * map038就绪，即可执行oacc，【delay=(3or4)+1，其实是两组，但流水】map[03]=0,map[8]=2
  * map8 ready,exe vstore,map[8]=0

## 指令相关性

迭代相关用busyVec处理：

* 同一条指令只有先来的那个指令会被执行
* 指令在插入iq和插入notrdyList时都是按序的

数据和控制相关用map处理：

| ins        | 数据前相关                       | 控制前相关 | 数据后相关 | 控制后相关          |
| ---------- | -------------------------------- | ---------- | ---------- | ------------------- |
| ld_tilerow | rs1-地址                         | map[rd]=0  | map[rd]=1  |                     |
| aamul      | map[idx12]=1<br />*map[idx1+4]=1 |            | map[rd]=2  |                     |
| triadd     | map[idx123]=2                    |            | map[0/3]=3 | ~~map[idx12]=0？~~ |
| oacc       | map[03]=3<br />map[8]=1          |            | map[8]=2   | map[0123]=0         |
| wb_tile    | map[8]=2<br />rs1-地址           |            |            | map[8]=0            |

## QA

* 为什么不一下子读16个

  * 因为部件有限，不想等前面16个数全部清空才唤醒指令
  * 对于后面指令的唤醒也有同样的道理
  * 此外，这里load部件刚好也是4个，做4*4也算合理
* 那为什么不能1个1个读

  * 首先是感觉可能一起读效率高
  * 其次是后面我需要进行向量操作
    * 因为发现扩充部件后，刚好有合适的策略
      * 可以流水啥的

## Code

* 之前没咋记录，可能只能看看github提交记录了
* iq-insert，writebackinst_wakeup是两个关键点，看看注释
