# 指令编码

* opcode=0x0b 00010[0x02]+11(其余的都是压缩指令)
* **注意，aamul 23可能有问题，实际去做的时候，感觉可以直接做成一条指令！因为是流水，所以延迟也就多一拍**
* 更新kernel时map该怎么办？
* 多次迭代间可能有问题
  * 指令先来肯定比后来先做
  * ckpt_sn去做

| ins        | funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12]  | rd[11:7]                        |
| ---------- | ------------- | ---------- | ---------- | -------------- | ------------------------------- |
| ld_tilerow | 1             | /          | 地址       | 010            | 0:output 1-4:input 5-8:kernel   |
| aamul      | 2             | /          | /          | 000【没用GPR】 | 00101-1 00110-2 10110-3 01010-4 |
| triadd     | 3             | /          | /          | 000【没用GPR】 | 00111-1 01110-4                 |
| oacc       | 4             | /          | /          | 000【没用GPR】 | 00001-0前两个 01000-0后两个槽   |
| wb_tile    | 5             | /          | 地址       | 010            | /                               |

## 指令相关性

有个map长度为9：

| ins        | 数据前相关                   | 控制前相关 | 数据后相关    | 控制后相关       |
| ---------- | ---------------------------- | ---------- | ------------- | ---------------- |
| ld_tilerow | rs1-地址                     | map[rd]=0  | map[rd]=1     |                  |
| aamul      | map[idx]=1<br />map[k_idx]=1 |            | map[rd]=2     |                  |
| triadd     | map[idx]=2                   |            | map[rd]=4     | ~~map[rd+2]=0~~ |
| oacc       | map[idx]=4<br />map[0]=1     |            | map[0][idx]=1 | map[idx,idx+2]=0 |
| wb_tile    | map[0]=10011<br />rs1-地址   |            |               | map[0]=0         |

## 策略

* 流水部件 4+ 4+ 4*
  * 两组相加 组内相加 组Kernel相乘   	加加乘 6or7
  * 两组相加 再加一组  				三组加加 3or4
  * abcAbcdB 各加一次				两层加法 3or4

## QA

* 为什么不一下子读16个

  * 因为部件有限，不想等前面16个数全部清空才唤醒指令
  * 对于后面指令的唤醒也有同样的道理
* 那为什么不能1个1个读

  * 首先是感觉可能一起读效率高
  * 其次是后面我需要进行向量操作

    * 因为发现扩充部件后，刚好有合适的策略
      * 可以流水啥的
