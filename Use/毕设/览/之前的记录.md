* 基本都没用了--
* ~~怎么做~~

  * 难的感觉是做不出来，看了个Eyeris看不太懂（而且感觉C语言源码上也要做很多工作
  * 做成脉动阵列的形式，同流水线紧密连接

    * 就是弄一个PE阵列，里面有一些计算单元，存放着权重，让特征图流动过去，可以复用数据
      * 难的话就可以弄成可配置的
      * 大小还没想好，然后可以考虑多通道并行
      * 如果想省事就设为最大
      * 如果弄小，算法层面也要做支持
    * 采用以行为单位指令进行计算，简单，步长可在指令中指定
    * 数据的宽度直接在c语言里设定为16bit，或者手动量化8bit
      * 若是要手动量化的话，中间可能有溢出的问题，还得设计量化部件
      * 可以先指定成16bit，然后后续再整量化的事
    * 设计的指令1：ifmap初始地址-寄存器，卷积横移size（可能根据行的大小来）-寄存器，输出的是ofmap的首地址，opcode从custom里面选一个，func字段用于区分
      * 2：load卷积核
    * 1卷积的具体操作
      * 先读到buffer里
      * 下一拍开始填充PEs
      * 填充好了开始计算，每移动一次算一些乘法，考虑到时序，累加在后面的拍用流水的方式进行也行
  * 设计一个缓存，得大点，计算的同时猝发读，读取的速度要大于等于IFMAP移动步长划过的数据

    * buffer这可能得需要一些创新点-使得来到第二行的时候，有缓存的数据可用
      * 我那种将二三行叠着以复用的想法不行，因为最下面的总会内啥
    * 猝发读最高支持	256次 128b每次	猝发的次数算好了在纸上
    * kernel行数最好小点，因为读内存按行
  * 实验框架打算用果壳，32位顺序处理器，有差分测试框架可以debug

    * 已经可以跑通他那个仿真
    * 有错误的话应该是可以调出波形来看
  * 软件方面就按行来展开
* ![1702374331026](image/now/1702374331026.png)





文章

* 1暂时不看了，有关压缩精度
* 0是软件上用winograd算法，把卷积降维；硬件方面估计做得很简单，就是简单的乘累加，做5*5的
* 2是向量寄存器文件+16bit+9次load+点积
* 3自己做处理器+乒乓《同一个卷积核，不同的特征图交替地load和计算》+vload/vstore/乘法加法（没用MAC）
* 4是整的加速器+可重配置（其实也就是调整卷积、池化、全连接的顺序，做不同的任务（lenet-5识别，边缘检测等


# record

## 1205

* 今天到上交这篇，前面看得还好
  * ~~但是二维阵列和eyeris都没说清楚咋算的~~
    * 想看eyeris但是感觉好难
  * 更别提它后面的了
* 网上那篇讲得倒是清楚
  * 但是那是矩阵乘，而卷积不是那样流动数据
  * **所以我很想想清楚卷积的脉动阵列应该咋做**
    * “咋做”：不只是逻辑上的，更要看“怎么做”
    * 这也是明天的重点：
      * 先通过思考、网上查找弄明白脉动阵列
      * 若有时间再看看eyeris和上交接下来的

## 1206

* sjtu里描述的二维弄明白了
  * 现在两条路
    * 一是网上描述~~TPU的那个~~，二是sjtu继续往下看，三是网上其他的脉动阵列，其他文章还要看吗？（快速过，看有无新东西
    * but想先看看代码，lenet.c

## 1207

* winograd那篇的源码看了看
  * 算法体现在：做了个reshape，把循环拆解到16为单位的大小，
  * 汇编能做的就是把16个数字的首地址和size分别给到两个寄存器里，算出来的值给到int里
  * 然后硬件就是做那16个数字的卷积
  * 那些数组copy的话可能是防止编译优化
