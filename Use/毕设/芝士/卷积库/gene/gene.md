<!--
 * @Author: lt 1035768203@qq.com
 * @Date: 2024-02-26 14:09:02
 * @LastEditors: lt 1035768203@qq.com
 * @LastEditTime: 2024-03-05 10:10:14
 * @FilePath: \workspace\Use\毕设\芝士\卷积库\gene\gene.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

# GENE

1. 小程序段性能调优 --- 大程序功能验证
2. 方法论

   1. 目前使用reset可以把输出截断，优化等级用-Ofast
   2. 要切分基本块的话，感觉借助模拟器的输出pc写个python脚本应该不难实现
3. 各维度

   1. 卷积：目前是 `col+gemmING`,`winogradING` ~~vectorized~~待，也可以都搞
   2. `dilated_conv`有在darknet上现成的开源，待
   3. `transpose_conv`例如fcn有在caffe上实现
      1. 学caffe工作量大，不过darknet是个好的入手点
      2. 也可以看着源码来搭建？-darknet里可能已经有 `deconv`
      3. 亦或是做一个简单的demo单纯验证功能性，到后期在尝试跑大的网络
   4. `deformable_conv`量大，可能会是个好点，不过估计不好验证
4. 想到的点

   1. gemm找到gem5中一个依赖性预测bug（详见memdep里的pre啥的，根据pc查表，有论文），然后发现有错误的预测导致sw后的lw发射过晚
   2. im2col要结合col2im分析，涉及到load-store这样的指令，可以设计扩展指令
      1. 主要是darknet中的比较复杂，纸上有，也多看看
   3. WINO5可能把那块给用一条扩展指令给做了，它并没有很多sw，还得再细看
      1. 有人做过，但是他是一维，操作少，直接一条指令做完
      2. 我是二维，二维要把基础算法在大矩阵上累加啥的吧
         1. 我就是对基本算法中的一部分进行优化
   4. 稀疏-流水-pingpong
   5. 大矩阵拆分
5. Q

   1. 先扩展指令，再进行数据流的优化才比较合理吧，有些地方可能加上扩展指令就没那么多问题了
      1. 所以先别急着分析
      2. 扩展指令可以用数据流的方法去做
6. now

   1. 中期前【分析+设计指令】
      1. 服务器要下下周，在那之前两种方法都可以试下：

         1. 代码 环境【gem5和rv和konata】
         2. 可能要把 `所有代码zip和konata和rv工具链`压缩下来让他传
         3. 不如用下面这个网页里的docker
         4. 不知道这个网页[gem5bootcamp/gem5-bootcamp-env (github.com)](https://github.com/gem5bootcamp/gem5-bootcamp-env)上的有没有用，毕竟有prebuilt好的玩意儿，可能可以直接跑？![1709542940223](image/gene/1709542940223.png)
      2. gemm【这个不太急，或者说不是大点】

         1. 改好毛病，**跑图，对比tick**
      3. im2col和col2im【大点】

         1. **就突然有了挺多想法，看看纸上**
            1. 明天查一查有没有人做过
            2. 可能那些for都不需要，改为设置reg值
            3. 全部应用的im2col，col2im都看看
               1. wino的倒还好
               2. darknet里那个还蛮复杂的，各种情况，看他的asm便可得出
            4. 【**`分析的部分中期之前完成`**】可以写在论文里
            5. ~~v扩展大概是不会去做了，所以v的先放下，当然那些资料啥的也挺好的，有时间可以看看~~
               1. ~~simd~~
                  1. ~~rvv-pdf里后面详细，且开头有两个网站~~
                     1. ~~看了看代码，确实是实现了，就是o3没include这个FU~~
                        1. ~~minor是包含了正常的simd和V，o3只有个延迟为1的simd~~
                        2. ~~还得跑，编译工具链也得支持，网上有参考~~
                  2. ~~spec搭配知乎~~
                  3. ~~b站，网页收藏，src~~
               2. ~~burst~~
         2. 【**`指令的设计中期之前完成`**】
         3. **跑图，对比tick**
      4. wino5【中点】

         1. 查查别人做过的东西
         2. 那个是最核心的循环，除了循环里那部分，还可以再看看trace分析，不看也就算了【周一】
            1. 【**`分析的部分中期之前完成`**】
         3. 加指令
            1. 看看gem5官网，那个教程，还有计算所那个【**`指令的设计中期之前完成`**】
            2. **跑图，对比tick**
      5. 写写报告
   2. 最后阶段【实现+实验】
      1. 看看中期做的效果吧，时间余量大的话可以先探索下gem5的课程以及官网教程
         1. 官网教程

            1. doc/debugging ckpt tracing_cpu statics
         2. 我看那几个PPT可能有比较重要的部分

            1. 06中有详细的ISA相关，可查；还有训练，可练；还有个assembler没看懂
            2. 03slide27有m5动态编译的东西
            3. 02最后有访存发包啥的，前面是simObject【可以结合rvv.pdf去理解事件驱动编程】
            4. 04是cache什么的
         3. ![1709637132079](image/gene/1709637132079.png)降序
      2. **扩展指令的实现可以结合数据流吗**
      3. 上面3个点也差不多够了，看情况可以考虑
         1. 加上 ③扩张和④转置，
            1. 做这四个的通用，或者每个都有个点
            2. 可形变是一个美好的愿景
            3. wino3和wino4有通用的部分，就是一维wino，看看有没有必要做，然后可能也有一些其他的点
               1. 还有就是有没有必要，毕竟wino其实只需要一种就好了
      4. **完整的实验对比啥的**
      5. 写论文
